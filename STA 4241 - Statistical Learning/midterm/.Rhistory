p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% { findInterval(x = p, vec = lasso.cor) }
lasso.cor
findInterval(x = p, vec = lasso.cor
findInterval(x = p, vec = lasso.cor)
findInterval(x = p, vec = lasso.cor)
lasso.cor
findInterval(x = p, vec = lasso.cor)
findInterval(x = p, vec = sort(x = lasso.cor))
findInterval(x = p, vec = sort(x = lasso.cor))
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.index
nonzero.counter <- 4 * c(0)
nonzero.counter
nonzero.counter <- 4 * c(0, )
nonzero.counter
nonzero.counter <- rep(x = 0, times = 4)
nonzero.counter
lasso.model$beta
coef(object = lasso.model, s = 'lambda.min')
coef(object = lasso.model, s = lasso.model$lambda.min)
coef(object = lasso.model, s = lasso.model$lambda.min)
coef(object = lasso.model, s = 'lambda.min')
lasso.cv <- glmnet::cv.glmnet(x = X, y = Y)
coef(object = lasso.cv, s = 'lambda.min')
coef(object = lasso.cv, s = 'lambda.min')[p.index]
coef(object = lasso.cv, s = 'lambda.min') > 0
coef(object = lasso.cv, s = 'lambda.min')[p.index] > 0
coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0
as.numeric(x = coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0)
as.integer(x = coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0)
nonzero.counter + as.integer(x = coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0)
c(1, 1, 1, 1) + as.integer(x = coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0)
lasso.model$lambda
lasso.model$lambda[p.index]
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = lambda)
p.lambda <- lasso.model$lambda[p.index]
p.lambda
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = lambda)
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (lambda in p.lambda) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = lambda)
nonzero.counter <- nonzero.counter + as.integer(x = coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0)
}
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = lambda)
lasso.remodel$beta
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
lasso.remodel$beta
nonzero.counter <- nonzero.counter + as.integer(x = coef(object = lasso.cv, s = 'lambda.min')[p.index] != 0)
}
lasso.remodel$beta
# Part iii
nonzero.counter <- rep(x = 0, times = 200)
lasso.remodel$beta != 0
as.integer(x = lasso.remodel$beta != 0)
as.integer(x = lasso.remodel$beta != 0)
lasso.remodel$beta
lasso.remodel$beta[0]
lasso.remodel$beta[1]
lasso.remodel$beta[198]
lasso.remodel$beta[, 198]
lasso.remodel$beta == 0
lasso.remodel$beta != 0
lasso.remodel$beta == 0
!(lasso.remodel$beta == 0)
as.integer(x = !(lasso.remodel$beta == 0))
as.vector(x = !(lasso.remodel$beta == 0))
as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter <- nonzero.counter + outcomes
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter <- nonzero.counter + outcomes
nonzero.counter
# plot per selected correlation coefficient
for (i in 1:5) {
# data preparation
X <- generate.X()
Y <- generate.Y(X = X)
# creating models
lasso.model <- glmnet::glmnet(x = X, y = Y, alpha = 1)
lasso.cor  <- foreach::foreach(j = 1:lasso.numcol, .combine = 'c') %do% {
tryCatch(
expr = {
cor(x = beta, y = as.numeric(x = lasso.model$beta[, j]))
},
warning = function(w) { 0.0 }
)
}
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.lambda <- lasso.model$lambda[p.index]
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter <- nonzero.counter + outcomes
}
}
generate.X <- function() {
# correlation
correlation.matrix <- matrix(data = cor(x = MASS::mvrnorm(n = n, mu = mu, Sigma = eye)), nrow = p, byrow = TRUE)
# covariance matrix
Sigma <- matrix(data = rep(x = 0, times = p^2), nrow = p, byrow = TRUE)
Sigma.func <- function(i, j) correlation.matrix[i, j] ^ abs(x = i - j)
for (i in 1:p) {
for (j in 1:p) {
Sigma[i, j] <- Sigma.func(i, j)
}
}
# generated data
MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma)
}
# Part iii
nonzero.counter <- data.frame(P1 = c(), P2 = c(), P3 = c(), P4 = c())
nonzero.counter
nonzero.counter[, j] <- nonzero.counter + outcomes
nonzero.counter$P1 <- nonzero.counter + outcomes
nonzero.counter$3 <- nonzero.counter + outcomes
sprintf('nonzero.counter$P%i', j, character.only = TRUE) <- nonzero.counter + outcomes
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
sprintf('nonzero.counter$P%i', j, character.only = TRUE) <- nonzero.counter + outcomes
sprintf('nonzero.counter$P%i', j, character.only = TRUE)
length(sprintf('nonzero.counter$P%i', j, character.only = TRUE))
length(sprintf('nonzero.counter$P%i', 1, character.only = TRUE))
length(sprintf('nonzero.counter$P%i', 1, character.only = TRUE))
nonzero.counter[, 1] <- nonzero.counter + outcomes
# Part iii
nonzero.counter <- data.frame(P1 = rep(x = 0, times = nsim),
# Part iii
nonzero.counter <- data.frame(P1 = rep(x = 0, times = nsim),
P2 = rep(x = 0, times = nsim),
P3 = rep(x = 0, times = nsim),
P4 = rep(x = 0, times = nsim))
# Part iii
nonzero.counter <- data.frame(P1 = rep(x = 0, times = nsim),
P2 = rep(x = 0, times = nsim),
P3 = rep(x = 0, times = nsim),
P4 = rep(x = 0, times = nsim))
dim(nonzero.counter)
nonzero.counter[, 1] <- nonzero.counter + outcomes
nonzero.counter[, 1] <- nonzero.counter[, 1] + outcomes
# Part iii
nonzero.counter <- data.frame(P1 = rep(x = 0, times = p),
P2 = rep(x = 0, times = p),
P3 = rep(x = 0, times = p),
P4 = rep(x = 0, times = p))
dim(nonzero.counter)
p <- 200
# Part iii
nonzero.counter <- data.frame(P1 = rep(x = 0, times = 200),
P2 = rep(x = 0, times = 200),
P3 = rep(x = 0, times = 200),
P4 = rep(x = 0, times = 200))
dim(nonzero.counter)
nonzero.counter[, 1] <- nonzero.counter[, 1] + outcomes
# data preparation
X <- generate.X()
Y <- generate.Y(X = X)
# creating models
lasso.model <- glmnet::glmnet(x = X, y = Y, alpha = 1)
lasso.cor  <- foreach::foreach(j = 1:lasso.numcol, .combine = 'c') %do% {
tryCatch(
expr = {
cor(x = beta, y = as.numeric(x = lasso.model$beta[, j]))
},
warning = function(w) { 0.0 }
)
}
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.lambda <- lasso.model$lambda[p.index]
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter[, j] <- nonzero.counter[, j] + outcomes
}
nonzero.counter
# plot per selected correlation coefficient
for (i in 1:nsim) {
# data preparation
X <- generate.X()
Y <- generate.Y(X = X)
# creating models
lasso.model <- glmnet::glmnet(x = X, y = Y, alpha = 1)
lasso.cor  <- foreach::foreach(j = 1:lasso.numcol, .combine = 'c') %do% {
tryCatch(
expr = {
cor(x = beta, y = as.numeric(x = lasso.model$beta[, j]))
},
warning = function(w) { 0.0 }
)
}
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.lambda <- lasso.model$lambda[p.index]
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter[, j] <- nonzero.counter[, j] + outcomes
}
}
generate.X <- function() {
# correlation
correlation.matrix <- matrix(data = cor(x = MASS::mvrnorm(n = n, mu = mu, Sigma = eye)), nrow = p, byrow = TRUE)
# covariance matrix
Sigma <- matrix(data = rep(x = 0, times = p^2), nrow = p, byrow = TRUE)
Sigma.func <- function(i, j) correlation.matrix[i, j] ^ abs(x = i - j)
for (i in 1:p) {
for (j in 1:p) {
Sigma[i, j] <- Sigma.func(i, j)
}
}
# generated data
MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma)
}
# plot per selected correlation coefficient
for (i in 1:nsim) {
# data preparation
X <- generate.X()
Y <- generate.Y(X = X)
# creating models
lasso.model <- glmnet::glmnet(x = X, y = Y, alpha = 1)
lasso.cor  <- foreach::foreach(j = 1:lasso.numcol, .combine = 'c') %do% {
tryCatch(
expr = {
cor(x = beta, y = as.numeric(x = lasso.model$beta[, j]))
},
warning = function(w) { 0.0 }
)
}
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.lambda <- lasso.model$lambda[p.index]
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter[, j] <- nonzero.counter[, j] + outcomes
}
}
# data preparation
X <- generate.X()
# data preparation
X <- generate.X()
n <- 100
p <- 200
mu <- rep(x = 0, times = p)
eye <- as.matrix(x = diag(x = p), nrow = p, byrow = TRUE)
generate.X <- function() {
# correlation
correlation.matrix <- matrix(data = cor(x = MASS::mvrnorm(n = n, mu = mu, Sigma = eye)), nrow = p, byrow = TRUE)
# covariance matrix
Sigma <- matrix(data = rep(x = 0, times = p^2), nrow = p, byrow = TRUE)
Sigma.func <- function(i, j) correlation.matrix[i, j] ^ abs(x = i - j)
for (i in 1:p) {
for (j in 1:p) {
Sigma[i, j] <- Sigma.func(i, j)
}
}
# generated data
MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma)
}
# correlation
correlation.matrix <- matrix(data = cor(x = MASS::mvrnorm(n = n, mu = mu, Sigma = eye)), nrow = p, byrow = TRUE)
# covariance matrix
Sigma <- matrix(data = rep(x = 0, times = p^2), nrow = p, byrow = TRUE)
Sigma.func <- function(i, j) correlation.matrix[i, j] ^ abs(x = i - j)
for (i in 1:p) {
for (j in 1:p) {
Sigma[i, j] <- Sigma.func(i, j)
}
}
# generated data
MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma)
generate.X <- function() {
# correlation
correlation.matrix <- matrix(data = cor(x = MASS::mvrnorm(n = n, mu = mu, Sigma = eye)), nrow = p, byrow = TRUE)
# covariance matrix
Sigma <- matrix(data = rep(x = 0, times = p^2), nrow = p, byrow = TRUE)
Sigma.func <- function(i, j) correlation.matrix[i, j] ^ abs(x = i - j)
for (i in 1:p) {
for (j in 1:p) {
Sigma[i, j] <- Sigma.func(i, j)
}
}
# generated data
MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma)
}
generate.X
# data preparation
X <- generate.X()
# plot per selected correlation coefficient
for (i in 1:nsim) {
# data preparation
X <- generate.X()
Y <- generate.Y(X = X)
# creating models
lasso.model <- glmnet::glmnet(x = X, y = Y, alpha = 1)
lasso.cor  <- foreach::foreach(j = 1:lasso.numcol, .combine = 'c') %do% {
tryCatch(
expr = {
cor(x = beta, y = as.numeric(x = lasso.model$beta[, j]))
},
warning = function(w) { 0.0 }
)
}
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.lambda <- lasso.model$lambda[p.index]
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter[, j] <- nonzero.counter[, j] + outcomes
}
}
# data preparation
X <- generate.X()
generate.X <- function() {
# correlation
correlation.matrix <- matrix(data = cor(x = MASS::mvrnorm(n = n, mu = mu, Sigma = eye)), nrow = 200, byrow = TRUE)
# covariance matrix
Sigma <- matrix(data = rep(x = 0, times = 200^2), nrow = 200, byrow = TRUE)
Sigma.func <- function(i, j) correlation.matrix[i, j] ^ abs(x = i - j)
for (i in 1:200) {
for (j in 1:200) {
Sigma[i, j] <- Sigma.func(i, j)
}
}
# generated data
MASS::mvrnorm(n = 100, mu = mu, Sigma = Sigma)
}
# plot per selected correlation coefficient
for (i in 1:nsim) {
# data preparation
X <- generate.X()
Y <- generate.Y(X = X)
# creating models
lasso.model <- glmnet::glmnet(x = X, y = Y, alpha = 1)
lasso.cor  <- foreach::foreach(j = 1:lasso.numcol, .combine = 'c') %do% {
tryCatch(
expr = {
cor(x = beta, y = as.numeric(x = lasso.model$beta[, j]))
},
warning = function(w) { 0.0 }
)
}
# indexes of select correlations from glmnet that each align with some lambda
p.index <- foreach::foreach(p = c(0.50, 0.75, 0.90, 0.99),  .combine = 'c') %do% {
findInterval(x = p, vec = sort(x = lasso.cor))
}
p.lambda <- lasso.model$lambda[p.index]
# keeping count of nonzero coefficients that correspond to nonzero coefficients in question
for (j in 1:4) {
lasso.remodel <- glmnet::glmnet(x = X, y = Y, alpha = 1, lambda = p.lambda[j])
outcomes <- as.integer(x = as.vector(x = !(lasso.remodel$beta == 0)))
nonzero.counter[, j] <- nonzero.counter[, j] + outcomes
}
}
plot(nonzero.counter)
plot(nonzero.counter / nsim)
ggplot(data = nonzero.counter) + geom_bar(aes(x = 1:200, y = P1 / nsim))
ggplot(data = nonzero.counter) + geom_bar(aes(x = c(1:200), y = P1 / nsim))
ggplot(data = nonzero.counter, aes(x = c(1:200), y = P1 / nsim)) + geom_bar()
ggplot(data = nonzero.counter, aes(x = c(1:200), y = P1 / nsim)) + geom_histogram()
ggplot(data = nonzero.counter, aes(x = c(1:200), y = P1 / nsim)) + geom_histogram(stat = 'identity')
ggplot(data = nonzero.counter, aes(x = c(1:200), y = P1 / nsim)) + geom_histogram(stat = 'identity') +
xlab(label = 'Covariate Index') +
(label = 'Nonzero Coefficient Probability at p = 0.50')
ggplot(data = nonzero.counter, aes(x = c(1:200), y = P1 / nsim)) + geom_histogram(stat = 'identity') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.50')
ggplot(data = nonzero.counter) + geom_histogram(aes(x = c(1:200), y = P1 / nsim), stat = 'identity')
ggplot(data = nonzero.counter) +
geom_histogram(aes(x = c(1:200), y = P1 / nsim), stat = 'identity') +
geom_histogram(aes(x = c(1:200), y = P2 / nsim), stat = 'identity') +
geom_histogram(aes(x = c(1:200), y = P3 / nsim), stat = 'identity') +
geom_histogram(aes(x = c(1:200), y = P4 / nsim), stat = 'identity')
ggplot(data = nonzero.counter) +
geom_histogram(aes(x = c(1:200), y = P1 / nsim), stat = 'identity', color = '0.50') +
geom_histogram(aes(x = c(1:200), y = P2 / nsim), stat = 'identity', color = '0.75') +
geom_histogram(aes(x = c(1:200), y = P3 / nsim), stat = 'identity', color = '0.90') +
geom_histogram(aes(x = c(1:200), y = P4 / nsim), stat = 'identity', color = '0.99') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.50')
+
ggplot(data = nonzero.counter) + geom_histogram(aes(x = c(1:200), y = P1 / nsim), stat = 'identity') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.50')
ggplot(data = nonzero.counter) + geom_histogram(aes(x = c(1:200), y = P1 / nsim), stat = 'identity') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.50')
ggplot(data = nonzero.counter) + geom_histogram(aes(x = c(1:200), y = P2 / nsim), stat = 'identity') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.75')
ggplot(data = nonzero.counter) + geom_histogram(aes(x = c(1:200), y = P3 / nsim), stat = 'identity') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.90')
ggplot(data = nonzero.counter) + geom_histogram(aes(x = c(1:200), y = P4 / nsim), stat = 'identity') +
xlab(label = 'Covariate Index') +
ylab(label = 'Nonzero Coefficient Probability at p = 0.99')
# Question 4
# loading packages
packages <- c('car', 'caret', 'e1071', 'parallel', 'rstudioapi')
install.packages(packages)
install.packages(packages)
lapply(packages, library, character.only = TRUE)
ncores <- parallel::detectCores()
# Part i
probit.model <- stats::glm(formula = Y ~ ., data = train.df, family = binomial(link = 'probit'))
# loading datasets
setwd(dir = dirname(path = rstudioapi::getActiveDocumentContext()$path)[1])
train.data <- read.csv(file = './Data/Problem4training.csv', header = TRUE)
train.df <- as.data.frame(x = train.data)
test.data <- read.csv(file = './Data/Problem4testing.csv', header = TRUE)
test.df <- as.data.frame(x = test.data)
# Part i
probit.model <- stats::glm(formula = Y ~ ., data = train.df, family = binomial(link = 'probit'))
probit.pred <- predict(object = probit.model, newdata = test.df)
Metrics::mse(actual = test.df$Y, predicted = probit.pred)
predict(object = probit.model, newdata = test.df)
# Part ii
confint(object = probit.model, level = 0.77, method = 'exact')
# Part ii
# using bootstrap method to construct CI
boot.statistic <- function(data, index) {
model <- stats::glm(formula = Y ~ ., data = data, family = binomial(link = 'probit'), subset = index)
coefficients <- coef(object = model)
return (coefficients['X.1'] + exp(x = coefficients['X.2']) + coefficients['X.3'] ^ 2)
}
for (R in 10 * c(1:5)) {
probit.boot <- boot::boot(data = train.df, statistic = boot.statistic, R = R, ncpus = ncores - 1)
ci <- boot::boot.ci(boot.out = probit.boot, conf = 0.77, type = 'perc')
print(ci)
}
for (R in rep(x = 10, times = 5)) {
probit.boot <- boot::boot(data = train.df, statistic = boot.statistic, R = R, ncpus = ncores - 1)
ci <- boot::boot.ci(boot.out = probit.boot, conf = 0.77, type = 'perc')
print(ci)
}
for (R in rep(x = 10, times = 5)) {
probit.boot <- boot::boot(data = train.df, statistic = boot.statistic, R = R, ncpus = ncores - 1)
ci <- boot::boot.ci(boot.out = probit.boot, conf = 0.77, type = 'perc')
print(ci)
}
# Part v
# caret::train(x = train.df[, 2:ncol(x = train.df)], y = train.df$Y, method = 'glmStepAIC')
MASS::stepAIC(object = probit.model, direction = 'forward')
summary(object = probit.model)
(mod = probit.model)
# Part vi
# check for high collinearity (e.g. >= 0.80 in absolute value)
sym.correlation <- cor(x = train.df[, 2:ncol(x = train.df)], use = 'pairwise.complete.obs')
length(x = which(abs(x = sym.correlation) >= 0.80))
# OR compute VIF for each covariate
car::vif(mod = probit.model)
# Part vii
lda.model <- MASS::lda(formula = Y ~ ., data = train.df)
qda.model <- MASS::lda(formula = Y ~ ., data = train.df)
svm.radial.model <- e1071::tune.svm(
x = train.df[, 2:ncol(x = train.df)],
y = train.df$Y,
kernel = 'radial',
gamma = seq(0.1, 10.0, 0.1),
)
svm.poly.model <- e1071::tune.svm(
x = train.df[, 2:ncol(x = train.df)],
y = train.df$Y,
kernel = 'polynomial',
degree = c(1:10)
)
lda.model
predict(object = lda.model, newdata = test.df)
head(predict(object = lda.model, newdata = test.df))
predict(object = lda.model, newdata = test.df, type = 'response')
predict(object = lda.model, newdata = test.df, type = 'response')$class
as.numeric(x = predict(object = lda.model, newdata = test.df, type = 'response')$class)
as.numeric(x = predict(object = lda.model, newdata = test.df, type = 'response')$class) - 1
lda.pred <- as.numeric(x = predict(object = lda.model, newdata = test.df, type = 'response')$class) - 1
Metrics::accuracy(actual = train.df$Y, predicted = lda.pred)
Metrics::accuracy(actual = test.df$Y, predicted = lda.pred)
1  -Metrics::accuracy(actual = test.df$Y, predicted = lda.pred)
qda.pred <- as.numeric(x = predict(object = qda.model, newdata = test.df, type = 'response')$class) - 1
1 - Metrics::accuracy(actual = test.df$Y, predicted = qda.pred)
qda.pred <- as.numeric(x = predict(object = qda.model, newdata = test.df, type = 'response')$class) - 1
1 - Metrics::accuracy(actual = test.df$Y, predicted = qda.pred)
svm.poly.model <- e1071::tune.svm(
x = train.df[, 2:ncol(x = train.df)],
y = train.df$Y,
kernel = 'polynomial',
degree = c(1:10)
)
summary(svm.radial.model)
svm.radial.model
# contains err
svm.poly.model
